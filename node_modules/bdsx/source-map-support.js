"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.install = exports.getErrorSource = exports.remapAndPrintError = exports.remapStackLine = exports.remapStack = exports.remapError = exports.mapSourcePosition = exports.retrieveSourceMap = void 0;
const source_map_1 = require("source-map");
const util_1 = require("./util");
const path = require("path");
const fs = require("fs");
// Only install once if called multiple times
let uncaughtShimInstalled = false;
// Maps a file path to a string containing the file contents
const fileContentsCache = {};
// Maps a file path to a source map for that file
const sourceMapCache = {};
// Regex for detecting source maps
const reSourceMap = /^data:application\/json[^,]+base64,/;
// Priority list of retrieve handlers
const retrieveFileHandlers = [];
const retrieveMapHandlers = [];
function hasGlobalProcessEventEmitter() {
    return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}
function handlerExec(list) {
    return function (arg) {
        for (let i = 0; i < list.length; i++) {
            const ret = list[i](arg);
            if (ret) {
                return ret;
            }
        }
        return null;
    };
}
const retrieveFile = handlerExec(retrieveFileHandlers);
retrieveFileHandlers.push((path) => {
    // Trim the path to make sure there is no extra whitespace.
    path = path.trim();
    if (/^file:/.test(path)) {
        // existsSync/readFileSync can't handle file protocol, but once stripped, it works
        path = path.replace(/file:\/\/\/(\w:)?/, function (protocol, drive) {
            return drive ?
                '' : // file:///C:/dir/file -> C:/dir/file
                '/'; // file:///root-dir/file -> /root-dir/file
        });
    }
    if (path in fileContentsCache) {
        return fileContentsCache[path];
    }
    let contents = '';
    try {
        if (fs.existsSync(path)) {
            // Otherwise, use the filesystem
            contents = fs.readFileSync(path, 'utf8');
        }
    }
    catch (er) {
        /* ignore any errors */
    }
    return fileContentsCache[path] = contents;
});
// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
    if (!file)
        return url;
    const dir = path.dirname(file);
    const match = /^\w+:\/\/[^/]*/.exec(dir);
    let protocol = match ? match[0] : '';
    const startPath = dir.slice(protocol.length);
    if (protocol && /^\/\w:/.test(startPath)) {
        // handle file:///C:/ paths
        protocol += '/';
        return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
    }
    return protocol + path.resolve(dir.slice(protocol.length), url);
}
function retrieveSourceMapURL(source) {
    // Get the URL of the source map
    const fileData = retrieveFile(source);
    const re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
    // Keep executing the search to find the *last* sourceMappingURL to avoid
    // picking up sourceMappingURLs from comments, strings, etc.
    let lastMatch = null;
    let match;
    while ((match = re.exec(fileData)) !== null)
        lastMatch = match;
    if (!lastMatch)
        return null;
    return lastMatch[1];
}
// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
exports.retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(source => {
    let sourceMappingURL = retrieveSourceMapURL(source);
    if (!sourceMappingURL)
        return null;
    // Read the contents of the source map
    let sourceMapData;
    if (reSourceMap.test(sourceMappingURL)) {
        // Support source map URL as a data url
        const rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
        sourceMapData = Buffer.from(rawData, "base64").toString();
        sourceMappingURL = source;
    }
    else {
        // Support source map URLs relative to the source URL
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(sourceMappingURL);
    }
    if (!sourceMapData) {
        return null;
    }
    return {
        url: sourceMappingURL,
        map: sourceMapData
    };
});
function mapSourcePosition(position) {
    let sourceMap = sourceMapCache[position.source];
    if (!sourceMap) {
        // Call the (overrideable) retrieveSourceMap function to get the source map.
        const urlAndMap = exports.retrieveSourceMap(position.source);
        if (urlAndMap) {
            sourceMap = sourceMapCache[position.source] = {
                url: urlAndMap.url,
                map: new source_map_1.SourceMapConsumer(urlAndMap.map)
            };
            // Load all sources stored inline with the source map into the file cache
            // to pretend like they are already loaded. They may not exist on disk.
            if (sourceMap.map) {
                sourceMap.map.sources.forEach(function (source, i) {
                    const contents = sourceMap.map.sourceContentFor(source);
                    if (contents) {
                        const url = supportRelativeURL(sourceMap.url, source);
                        fileContentsCache[url] = contents;
                    }
                });
            }
        }
        else {
            sourceMap = sourceMapCache[position.source] = {
                url: null,
                map: null
            };
        }
    }
    // Resolve the source URL relative to the URL of the source map
    if (sourceMap && sourceMap.map) {
        const originalPosition = sourceMap.map.originalPositionFor(position);
        // Only return the original position if a matching line was found. If no
        // matching line is found then we return position instead, which will cause
        // the stack trace to print the path and line for the compiled file. It is
        // better to give a precise location in the compiled file than a vague
        // location in the original file.
        if (originalPosition.source !== null) {
            originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
            return originalPosition;
        }
    }
    return position;
}
exports.mapSourcePosition = mapSourcePosition;
// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
    // Most eval() calls are in this format
    let match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
    if (match) {
        const position = mapSourcePosition({
            source: match[2],
            line: +match[3],
            column: +match[4] - 1
        });
        return 'eval at ' + match[1] + ' (' + position.source + ':' +
            position.line + ':' + (position.column + 1) + ')';
    }
    // Parse nested eval() calls using recursion
    match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
    if (match) {
        return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
    }
    // Make sure we still return useful information if we didn't find anything
    return origin;
}
function remapError(err) {
    err.stack = remapStack(err.stack);
    return err;
}
exports.remapError = remapError;
/**
 * remap filepath to original filepath
 */
function remapStack(stack) {
    if (stack === undefined)
        return undefined;
    const state = { nextPosition: null, curPosition: null };
    const frames = stack.split('\n');
    let i = frames.length - 1;
    for (; i >= 1; i--) {
        const frame = remapStackLine(frames[i], state);
        if (frame.internal)
            continue;
        frames.length = i + 1;
        frames[i] = frame.stackLine;
        state.nextPosition = state.curPosition;
        break;
    }
    for (; i >= 1; i--) {
        const frame = remapStackLine(frames[i], state);
        frames[i] = frame.stackLine;
        state.nextPosition = state.curPosition;
    }
    return frames.join('\n');
}
exports.remapStack = remapStack;
/**
 * remap filepath to original filepath for one line
 */
function remapStackLine(stackLine, state = { nextPosition: null, curPosition: null }) {
    const matched = /^ {3}at (.+) \(([^(]+)\)$/.exec(stackLine);
    if (!matched)
        return { stackLine, internal: false };
    const fnname = matched[1];
    const source = matched[2];
    // provides interface backward compatibility
    if (source === 'native code' || source === 'native code:0:0') {
        state.curPosition = null;
        return { stackLine, internal: false };
    }
    const srcmatched = /^(.+):(\d+):(\d+)$/.exec(source);
    if (!srcmatched)
        return { stackLine, internal: false };
    const isEval = fnname === 'eval code';
    if (isEval) {
        return { stackLine, internal: false };
    }
    const file = srcmatched[1];
    const line = +srcmatched[2];
    const column = +srcmatched[3] - 1;
    const position = mapSourcePosition({
        source: file,
        line: line,
        column: column
    });
    state.curPosition = position;
    return {
        stackLine: `   at ${fnname} (${position.source}:${position.line}:${position.column + 1})`,
        internal: position.source.startsWith('internal/')
    };
}
exports.remapStackLine = remapStackLine;
/**
 * remap stack and print
 */
function remapAndPrintError(err) {
    if (err && err.stack) {
        console.error(remapStack(err.stack + ''));
    }
    else {
        console.error(err);
    }
}
exports.remapAndPrintError = remapAndPrintError;
// Generate position and snippet of original source with pointer
function getErrorSource(error) {
    const match = /\n {3}at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
    if (match) {
        const source = match[1];
        const line = +match[2];
        const column = +match[3];
        // Support the inline sourceContents inside the source map
        let contents = fileContentsCache[source];
        // Support files on disk
        if (!contents && fs && fs.existsSync(source)) {
            try {
                contents = fs.readFileSync(source, 'utf8');
            }
            catch (er) {
                contents = '';
            }
        }
        // Format the line from the original source code like node does
        if (contents) {
            const code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
            if (code) {
                return source + ':' + line + '\n' + code + '\n' +
                    new Array(column).join(' ') + '^';
            }
        }
    }
    return null;
}
exports.getErrorSource = getErrorSource;
function printErrorAndExit(error) {
    const source = getErrorSource(error);
    // Ensure error is printed synchronously and not truncated
    const handle = process.stderr._handle;
    if (handle && handle.setBlocking) {
        handle.setBlocking(true);
    }
    if (source) {
        console.error();
        console.error(source);
    }
    console.error(error.stack);
    process.exit(1);
}
function shimEmitUncaughtException() {
    const origEmit = process.emit;
    process.emit = function (type, ...args) {
        if (type === 'uncaughtException') {
            const err = args[0];
            const hasStack = (err && err.stack);
            const hasListeners = (this.listeners(type).length > 0);
            if (hasStack && !hasListeners) {
                err.stack = remapStack(err.stack);
                return printErrorAndExit(err);
            }
        }
        else if (type === 'unhandledRejection') {
            const err = args[0];
            err.stack = remapStack(err.stack);
        }
        return origEmit.apply(this, arguments);
    };
}
function install() {
    if (uncaughtShimInstalled)
        return;
    let installHandler = true;
    try {
        const worker_threads = module.require('worker_threads');
        if (worker_threads.isMainThread === false) {
            installHandler = false;
        }
    }
    catch (e) { }
    if (installHandler && hasGlobalProcessEventEmitter()) {
        uncaughtShimInstalled = true;
        shimEmitUncaughtException();
    }
    console.trace = function (...messages) {
        const err = remapStack(util_1.removeLine(Error(messages.map(util_1.anyToString).join(' ')).stack || '', 1, 2));
        console.error('Trace' + err.substr(5));
    };
}
exports.install = install;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic291cmNlLW1hcC1zdXBwb3J0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic291cmNlLW1hcC1zdXBwb3J0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLDJDQUErQztBQUMvQyxpQ0FBK0Q7QUFDL0QsNkJBQThCO0FBQzlCLHlCQUEwQjtBQXdCMUIsNkNBQTZDO0FBQzdDLElBQUkscUJBQXFCLEdBQUcsS0FBSyxDQUFDO0FBRWxDLDREQUE0RDtBQUM1RCxNQUFNLGlCQUFpQixHQUEyQixFQUFFLENBQUM7QUFFckQsaURBQWlEO0FBQ2pELE1BQU0sY0FBYyxHQUFxRCxFQUFFLENBQUM7QUFFNUUsa0NBQWtDO0FBQ2xDLE1BQU0sV0FBVyxHQUFHLHFDQUFxQyxDQUFDO0FBRTFELHFDQUFxQztBQUNyQyxNQUFNLG9CQUFvQixHQUFpQyxFQUFFLENBQUM7QUFDOUQsTUFBTSxtQkFBbUIsR0FBMkMsRUFBRSxDQUFDO0FBRXZFLFNBQVMsNEJBQTRCO0lBQ2pDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sT0FBTyxLQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxPQUFPLENBQUMsRUFBRSxLQUFLLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDdkcsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFPLElBQXVCO0lBQzlDLE9BQU8sVUFBVSxHQUFHO1FBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN6QixJQUFJLEdBQUcsRUFBRTtnQkFDTCxPQUFPLEdBQUcsQ0FBQzthQUNkO1NBQ0o7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFFdkQsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7SUFDL0IsMkRBQTJEO0lBQzNELElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbkIsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3JCLGtGQUFrRjtRQUNsRixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRSxVQUFVLFFBQVEsRUFBRSxLQUFLO1lBQzlELE9BQU8sS0FBSyxDQUFDLENBQUM7Z0JBQ1YsRUFBRSxDQUFDLENBQUMsQ0FBQyxxQ0FBcUM7Z0JBQzFDLEdBQUcsQ0FBQyxDQUFDLDBDQUEwQztRQUN2RCxDQUFDLENBQUMsQ0FBQztLQUNOO0lBQ0QsSUFBSSxJQUFJLElBQUksaUJBQWlCLEVBQUU7UUFDM0IsT0FBTyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQztJQUVELElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNsQixJQUFJO1FBQ0EsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3JCLGdDQUFnQztZQUNoQyxRQUFRLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDNUM7S0FDSjtJQUFDLE9BQU8sRUFBRSxFQUFFO1FBQ1QsdUJBQXVCO0tBQzFCO0lBRUQsT0FBTyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUM7QUFDOUMsQ0FBQyxDQUFDLENBQUM7QUFFSCwrRUFBK0U7QUFDL0UsMEZBQTBGO0FBQzFGLFNBQVMsa0JBQWtCLENBQUMsSUFBWSxFQUFFLEdBQVc7SUFDakQsSUFBSSxDQUFDLElBQUk7UUFBRSxPQUFPLEdBQUcsQ0FBQztJQUN0QixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9CLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QyxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3JDLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdDLElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDdEMsMkJBQTJCO1FBQzNCLFFBQVEsSUFBSSxHQUFHLENBQUM7UUFDaEIsT0FBTyxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZGO0lBQ0QsT0FBTyxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRUQsU0FBUyxvQkFBb0IsQ0FBQyxNQUFjO0lBQ3hDLGdDQUFnQztJQUNoQyxNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFLEdBQUcsdUhBQXVILENBQUM7SUFDbkkseUVBQXlFO0lBQ3pFLDREQUE0RDtJQUM1RCxJQUFJLFNBQVMsR0FBNEIsSUFBSSxDQUFDO0lBQzlDLElBQUksS0FBOEIsQ0FBQztJQUNuQyxPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUyxDQUFDLENBQUMsS0FBSyxJQUFJO1FBQUUsU0FBUyxHQUFHLEtBQUssQ0FBQztJQUNoRSxJQUFJLENBQUMsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDO0lBQzVCLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRCx3RUFBd0U7QUFDeEUsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RSx3RUFBd0U7QUFDeEUsZ0JBQWdCO0FBQ0gsUUFBQSxpQkFBaUIsR0FBRyxXQUFXLENBQUMsbUJBQW1CLENBQUMsQ0FBQztBQUNsRSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7SUFDOUIsSUFBSSxnQkFBZ0IsR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsZ0JBQWdCO1FBQUUsT0FBTyxJQUFJLENBQUM7SUFFbkMsc0NBQXNDO0lBQ3RDLElBQUksYUFBNEIsQ0FBQztJQUNqQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUNwQyx1Q0FBdUM7UUFDdkMsTUFBTSxPQUFPLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMxRSxhQUFhLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDMUQsZ0JBQWdCLEdBQUcsTUFBTSxDQUFDO0tBQzdCO1NBQU07UUFDSCxxREFBcUQ7UUFDckQsZ0JBQWdCLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDaEUsYUFBYSxHQUFHLFlBQVksQ0FBQyxnQkFBaUIsQ0FBQyxDQUFDO0tBQ25EO0lBRUQsSUFBSSxDQUFDLGFBQWEsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQztLQUNmO0lBRUQsT0FBTztRQUNILEdBQUcsRUFBRSxnQkFBaUI7UUFDdEIsR0FBRyxFQUFFLGFBQWE7S0FDckIsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDO0FBUUgsU0FBZ0IsaUJBQWlCLENBQUMsUUFBa0I7SUFDaEQsSUFBSSxTQUFTLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUVoRCxJQUFJLENBQUMsU0FBUyxFQUFFO1FBQ1osNEVBQTRFO1FBQzVFLE1BQU0sU0FBUyxHQUFHLHlCQUFpQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyRCxJQUFJLFNBQVMsRUFBRTtZQUNYLFNBQVMsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHO2dCQUMxQyxHQUFHLEVBQUUsU0FBUyxDQUFDLEdBQUc7Z0JBQ2xCLEdBQUcsRUFBRSxJQUFJLDhCQUFpQixDQUFDLFNBQVMsQ0FBQyxHQUFVLENBQUM7YUFDbkQsQ0FBQztZQUVGLHlFQUF5RTtZQUN6RSx1RUFBdUU7WUFDdkUsSUFBSSxTQUFTLENBQUMsR0FBRyxFQUFFO2dCQUNmLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLE1BQU0sRUFBRSxDQUFDO29CQUM3QyxNQUFNLFFBQVEsR0FBRyxTQUFVLENBQUMsR0FBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUMxRCxJQUFJLFFBQVEsRUFBRTt3QkFDVixNQUFNLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxTQUFVLENBQUMsR0FBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO3dCQUN4RCxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUM7cUJBQ3JDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2FBQ047U0FDSjthQUFNO1lBQ0gsU0FBUyxHQUFHLGNBQWMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUc7Z0JBQzFDLEdBQUcsRUFBRSxJQUFJO2dCQUNULEdBQUcsRUFBRSxJQUFJO2FBQ1osQ0FBQztTQUNMO0tBQ0o7SUFFRCwrREFBK0Q7SUFDL0QsSUFBSSxTQUFTLElBQUksU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUM1QixNQUFNLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFckUsd0VBQXdFO1FBQ3hFLDJFQUEyRTtRQUMzRSwwRUFBMEU7UUFDMUUsc0VBQXNFO1FBQ3RFLGlDQUFpQztRQUVqQyxJQUFJLGdCQUFnQixDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7WUFDbEMsZ0JBQWdCLENBQUMsTUFBTSxHQUFHLGtCQUFrQixDQUN4QyxTQUFTLENBQUMsR0FBSSxFQUFFLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzdDLE9BQU8sZ0JBQWdCLENBQUM7U0FDM0I7S0FDSjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ3BCLENBQUM7QUFqREQsOENBaURDO0FBRUQscUVBQXFFO0FBQ3JFLG1FQUFtRTtBQUNuRSxTQUFTLGFBQWEsQ0FBQyxNQUFjO0lBQ2pDLHVDQUF1QztJQUN2QyxJQUFJLEtBQUssR0FBRyx3Q0FBd0MsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbEUsSUFBSSxLQUFLLEVBQUU7UUFDUCxNQUFNLFFBQVEsR0FBRyxpQkFBaUIsQ0FBQztZQUMvQixNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNoQixJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ2YsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7U0FDeEIsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxRQUFRLENBQUMsTUFBTSxHQUFHLEdBQUc7WUFDdkQsUUFBUSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztLQUN6RDtJQUVELDRDQUE0QztJQUM1QyxLQUFLLEdBQUcsNEJBQTRCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xELElBQUksS0FBSyxFQUFFO1FBQ1AsT0FBTyxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ3ZFO0lBRUQsMEVBQTBFO0lBQzFFLE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUM7QUFFRCxTQUFnQixVQUFVLENBQWtCLEdBQU07SUFDOUMsR0FBRyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2xDLE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUhELGdDQUdDO0FBT0Q7O0dBRUc7QUFDSCxTQUFnQixVQUFVLENBQUMsS0FBYztJQUNyQyxJQUFJLEtBQUssS0FBSyxTQUFTO1FBQUUsT0FBTyxTQUFTLENBQUM7SUFFMUMsTUFBTSxLQUFLLEdBQWUsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNwRSxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNoQixNQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQy9DLElBQUksS0FBSyxDQUFDLFFBQVE7WUFBRSxTQUFTO1FBQzdCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUM1QixLQUFLLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7UUFDdkMsTUFBTTtLQUNUO0lBQ0QsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2hCLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDL0MsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7UUFDNUIsS0FBSyxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO0tBQzFDO0lBQ0QsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFwQkQsZ0NBb0JDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixjQUFjLENBQUMsU0FBaUIsRUFBRSxRQUFvQixFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTtJQUUzRyxNQUFNLE9BQU8sR0FBRywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDNUQsSUFBSSxDQUFDLE9BQU87UUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUNwRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTFCLDRDQUE0QztJQUM1QyxJQUFJLE1BQU0sS0FBSyxhQUFhLElBQUksTUFBTSxLQUFLLGlCQUFpQixFQUFFO1FBQzFELEtBQUssQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDO0tBQ3pDO0lBQ0QsTUFBTSxVQUFVLEdBQUcsb0JBQW9CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxVQUFVO1FBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUM7SUFFdkQsTUFBTSxNQUFNLEdBQUcsTUFBTSxLQUFLLFdBQVcsQ0FBQztJQUN0QyxJQUFJLE1BQU0sRUFBRTtRQUNSLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDO0tBQ3pDO0lBRUQsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLE1BQU0sSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVCLE1BQU0sTUFBTSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVsQyxNQUFNLFFBQVEsR0FBRyxpQkFBaUIsQ0FBQztRQUMvQixNQUFNLEVBQUUsSUFBSTtRQUNaLElBQUksRUFBRSxJQUFJO1FBQ1YsTUFBTSxFQUFFLE1BQU07S0FDakIsQ0FBQyxDQUFDO0lBQ0gsS0FBSyxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUM7SUFDN0IsT0FBTztRQUNILFNBQVMsRUFBRSxTQUFTLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUc7UUFDekYsUUFBUSxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQztLQUNwRCxDQUFDO0FBQ04sQ0FBQztBQWxDRCx3Q0FrQ0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLEdBQW1CO0lBQ2xELElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7UUFDbEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQzdDO1NBQU07UUFDSCxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3RCO0FBQ0wsQ0FBQztBQU5ELGdEQU1DO0FBRUQsZ0VBQWdFO0FBQ2hFLFNBQWdCLGNBQWMsQ0FBQyxLQUFZO0lBQ3ZDLE1BQU0sS0FBSyxHQUFHLHFDQUFxQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBTSxDQUFDLENBQUM7SUFDdkUsSUFBSSxLQUFLLEVBQUU7UUFDUCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFekIsMERBQTBEO1FBQzFELElBQUksUUFBUSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXpDLHdCQUF3QjtRQUN4QixJQUFJLENBQUMsUUFBUSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzFDLElBQUk7Z0JBQ0EsUUFBUSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQzlDO1lBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ1QsUUFBUSxHQUFHLEVBQUUsQ0FBQzthQUNqQjtTQUNKO1FBRUQsK0RBQStEO1FBQy9ELElBQUksUUFBUSxFQUFFO1lBQ1YsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN4RCxJQUFJLElBQUksRUFBRTtnQkFDTixPQUFPLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSTtvQkFDM0MsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQzthQUN6QztTQUNKO0tBQ0o7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBN0JELHdDQTZCQztBQUVELFNBQVMsaUJBQWlCLENBQUMsS0FBWTtJQUNuQyxNQUFNLE1BQU0sR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFckMsMERBQTBEO0lBQzFELE1BQU0sTUFBTSxHQUFJLE9BQU8sQ0FBQyxNQUFjLENBQUMsT0FBTyxDQUFDO0lBQy9DLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7UUFDOUIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM1QjtJQUVELElBQUksTUFBTSxFQUFFO1FBQ1IsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2hCLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDekI7SUFFRCxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLENBQUM7QUFFRCxTQUFTLHlCQUF5QjtJQUM5QixNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0lBRTlCLE9BQU8sQ0FBQyxJQUFJLEdBQUcsVUFBVSxJQUFZLEVBQUUsR0FBRyxJQUFVO1FBQ2hELElBQUksSUFBSSxLQUFLLG1CQUFtQixFQUFFO1lBQzlCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQixNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDcEMsTUFBTSxZQUFZLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUV2RCxJQUFJLFFBQVEsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDM0IsR0FBRyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNsQyxPQUFPLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2pDO1NBQ0o7YUFBTSxJQUFJLElBQUksS0FBSyxvQkFBb0IsRUFBRTtZQUN0QyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsR0FBRyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMzQyxDQUFDLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBZ0IsT0FBTztJQUNuQixJQUFJLHFCQUFxQjtRQUFFLE9BQU87SUFDbEMsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDO0lBQzFCLElBQUk7UUFDQSxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDeEQsSUFBSSxjQUFjLENBQUMsWUFBWSxLQUFLLEtBQUssRUFBRTtZQUN2QyxjQUFjLEdBQUcsS0FBSyxDQUFDO1NBQzFCO0tBQ0o7SUFBQyxPQUFPLENBQUMsRUFBRSxHQUFHO0lBRWYsSUFBSSxjQUFjLElBQUksNEJBQTRCLEVBQUUsRUFBRTtRQUNsRCxxQkFBcUIsR0FBRyxJQUFJLENBQUM7UUFDN0IseUJBQXlCLEVBQUUsQ0FBQztLQUMvQjtJQUVELE9BQU8sQ0FBQyxLQUFLLEdBQUcsVUFBUyxHQUFHLFFBQWM7UUFDdEMsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLGlCQUFVLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsa0JBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFFLENBQUM7UUFDbEcsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUMsQ0FBQztBQUNOLENBQUM7QUFuQkQsMEJBbUJDIn0=