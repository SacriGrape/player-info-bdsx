"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcHacker = void 0;
const assembler_1 = require("./assembler");
const core_1 = require("./core");
const disassembler_1 = require("./disassembler");
const dll_1 = require("./dll");
const hacktool_1 = require("./hacktool");
const makefunc_1 = require("./makefunc");
const unlocker_1 = require("./unlocker");
const util_1 = require("./util");
const colors = require("colors");
const FREE_REGS = [
    assembler_1.Register.rax,
    assembler_1.Register.r10,
    assembler_1.Register.r11,
];
class AsmMover extends assembler_1.X64Assembler {
    constructor(origin, codesize) {
        super(new Uint8Array(32), 0);
        this.origin = origin;
        this.codesize = codesize;
        this.freeregs = new Set(FREE_REGS);
        this.inpos = 0;
    }
    getUnusing() {
        for (const r of this.freeregs.values()) {
            return r;
        }
        return null;
    }
    asmFromOrigin(oper) {
        const splits = oper.splits;
        const basename = splits[0];
        let ripDependedParam = null;
        const params = oper.parameters();
        for (const info of params) {
            switch (info.type) {
                case 'r':
                    this.freeregs.delete(info.register);
                    break;
                case 'rp':
                    this.freeregs.delete(info.register);
                    if (info.register === assembler_1.Register.rip) {
                        ripDependedParam = info;
                    }
                    break;
            }
        }
        if ((basename.startsWith('j') || basename === 'call') && splits.length === 2 && splits[1] === 'c') {
            // jump
            const offset = this.inpos + oper.args[0] + oper.size;
            if (offset < 0 || offset > this.codesize) {
                const tmpreg = this.getUnusing();
                if (tmpreg === null)
                    throw Error(`Not enough free registers`);
                const jmp_r = assembler_1.asm.code[basename + '_r'];
                if (jmp_r) {
                    this.mov_r_c(tmpreg, this.origin.add(offset));
                    jmp_r.call(this, tmpreg);
                }
                else {
                    const reversed = oper.reverseJump();
                    this[reversed + '_label']('!');
                    this.jmp64(this.origin.add(offset), tmpreg);
                    this.close_label('!');
                }
                this.inpos += oper.size;
                return;
            }
            else {
                // TOFIX: remap offset if the code size is changed when rewriting.
            }
        }
        else {
            if (ripDependedParam !== null) {
                const tmpreg = this.getUnusing();
                if (tmpreg === null)
                    throw Error(`Not enough free registers`);
                oper.args[ripDependedParam.argi] = tmpreg;
                oper.args[ripDependedParam.argi + 2] = 0;
                this.mov_r_c(tmpreg, this.origin.add(this.inpos + oper.size + ripDependedParam.offset));
                this[oper.splits.join('_')](...oper.args);
                this.inpos += oper.size;
                return;
            }
        }
        oper.code.apply(this, oper.args);
        this.inpos += oper.size;
    }
    end() {
        const tmpreg = this.getUnusing();
        const originend = this.origin.add(this.codesize);
        if (tmpreg != null)
            this.jmp64(originend, tmpreg);
        else
            this.jmp64_notemp(originend);
    }
}
class ProcHacker {
    constructor(map) {
        this.map = map;
    }
    append(nmap) {
        const map = this.map;
        for (const key in nmap) {
            map[key] = nmap[key];
        }
        return this;
    }
    /**
     * @param subject name of hooking
     * @param key target symbol
     * @param offset offset from target
     * @param ptr target pointer
     * @param originalCode old codes
     * @param ignoreArea pairs of offset, ignores partial bytes.
     */
    check(subject, key, offset, ptr, originalCode, ignoreArea) {
        const buffer = ptr.getBuffer(originalCode.length);
        const diff = util_1.memdiff(buffer, originalCode);
        if (!util_1.memdiff_contains(ignoreArea, diff)) {
            console.error(colors.red(`${subject}: ${key}+0x${offset.toString(16)}: code unmatch`));
            console.error(colors.red(`[${util_1.hex(buffer)}] != [${util_1.hex(originalCode)}]`));
            console.error(colors.red(`diff: ${JSON.stringify(diff)}`));
            console.error(colors.red(`${subject}: skip `));
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * @param subject for printing on error
     * @param key target symbol name
     * @param offset offset from target
     * @param originalCode bytes comparing before hooking
     * @param ignoreArea pair offsets to ignore of originalCode
     */
    nopping(subject, key, offset, originalCode, ignoreArea) {
        const ptr = this.map[key].add(offset);
        if (!ptr) {
            console.error(colors.red(`${subject}: skip, ${key} symbol not found`));
            return;
        }
        const size = originalCode.length;
        const unlock = new unlocker_1.MemoryUnlocker(ptr, size);
        if (this.check(subject, key, offset, ptr, originalCode, ignoreArea)) {
            dll_1.dll.vcruntime140.memset(ptr, 0x90, size);
        }
        unlock.done();
    }
    /**
     * @param key target symbol name
     * @param to call address
     */
    hookingRaw(key, to) {
        const origin = this.map[key];
        if (!origin)
            throw Error(`${key} symbol not found`);
        const REQUIRE_SIZE = 12;
        const codes = disassembler_1.disasm.process(origin, REQUIRE_SIZE);
        const out = new AsmMover(origin, codes.size);
        for (const oper of codes.operations) {
            const basename = oper.splits[0];
            if (basename === 'ret' || basename === 'jmp' || basename === 'call') {
                throw Error(`Too small area to patch, require=${REQUIRE_SIZE}, actual=${out.inpos}`);
            }
            out.asmFromOrigin(oper);
        }
        out.end();
        const original = out.alloc();
        const unlock = new unlocker_1.MemoryUnlocker(origin, codes.size);
        hacktool_1.hacktool.jump(origin, to, assembler_1.Register.rax, codes.size);
        unlock.done();
        return original;
    }
    /**
     * @param key target symbol name
     * @param to call address
     */
    hookingRawWithCallOriginal(key, to, keepRegister, keepFloatRegister) {
        const origin = this.map[key];
        if (!origin)
            throw Error(`${key} symbol not found`);
        const REQUIRE_SIZE = 12;
        const codes = disassembler_1.disasm.process(origin, REQUIRE_SIZE);
        const out = new AsmMover(origin, codes.size);
        for (const reg of keepRegister) {
            out.freeregs.add(reg);
        }
        out.saveAndCall(to, keepRegister, keepFloatRegister);
        for (const oper of codes.operations) {
            const basename = oper.splits[0];
            if (basename === 'ret' || basename === 'jmp' || basename === 'call') {
                throw Error(`Too small area to patch, require=${REQUIRE_SIZE}, actual=${out.inpos}`);
            }
            out.asmFromOrigin(oper);
        }
        out.end();
        const unlock = new unlocker_1.MemoryUnlocker(origin, codes.size);
        hacktool_1.hacktool.jump(origin, out.alloc(), assembler_1.Register.rax, codes.size);
        unlock.done();
    }
    /**
     * @param key target symbol name
     * @param to call address
     */
    hooking(key, returnType, opts, ...params) {
        return callback => {
            const to = makefunc_1.makefunc.np(callback, returnType, opts, ...params);
            return makefunc_1.makefunc.js(this.hookingRaw(key, to), returnType, opts, ...params);
        };
    }
    /**
     * @param subject for printing on error
     * @param key target symbol name
     * @param offset offset from target
     * @param newCode call address
     * @param tempRegister using register to call
     * @param call true - call, false - jump
     * @param originalCode bytes comparing before hooking
     * @param ignoreArea pair offsets to ignore of originalCode
     */
    patching(subject, key, offset, newCode, tempRegister, call, originalCode, ignoreArea) {
        let ptr = this.map[key];
        if (!ptr) {
            console.error(colors.red(`${subject}: skip, ${key} symbol not found`));
            return;
        }
        ptr = ptr.add(offset);
        if (!ptr) {
            console.error(colors.red(`${subject}: skip`));
            return;
        }
        const size = originalCode.length;
        const unlock = new unlocker_1.MemoryUnlocker(ptr, size);
        if (this.check(subject, key, offset, ptr, originalCode, ignoreArea)) {
            hacktool_1.hacktool.patch(ptr, newCode, tempRegister, size, call);
        }
        unlock.done();
    }
    /**
     * @param subject for printing on error
     * @param key target symbol name
     * @param offset offset from target
     * @param jumpTo jump address
     * @param tempRegister using register to jump
     * @param originalCode bytes comparing before hooking
     * @param ignoreArea pair offsets to ignore of originalCode
     */
    jumping(subject, key, offset, jumpTo, tempRegister, originalCode, ignoreArea) {
        let ptr = this.map[key];
        if (!ptr) {
            console.error(colors.red(`${subject}: skip, ${key} symbol not found`));
            return;
        }
        ptr = ptr.add(offset);
        const size = originalCode.length;
        const unlock = new unlocker_1.MemoryUnlocker(ptr, size);
        if (this.check(subject, key, offset, ptr, originalCode, ignoreArea)) {
            hacktool_1.hacktool.jump(ptr, jumpTo, tempRegister, size);
        }
        unlock.done();
    }
    write(key, offset, asm) {
        const buffer = asm.buffer();
        const ptr = this.map[key].add(offset);
        const unlock = new unlocker_1.MemoryUnlocker(ptr, buffer.length);
        ptr.writeBuffer(buffer);
        unlock.done();
    }
    /**
     * make the native function as a JS function.
     *
     * wrapper codes are not deleted permanently.
     * do not use it dynamically.
     *
     * @param returnType RawTypeId or *Pointer
     * @param params RawTypeId or *Pointer
     */
    js(key, returnType, opts, ...params) {
        return makefunc_1.makefunc.js(this.map[key], returnType, opts, ...params);
    }
    /**
     * get symbols from cache.
     * if symbols don't exist in cache. it reads pdb.
     */
    static load(cacheFilePath, names) {
        return new ProcHacker(core_1.pdb.getList(cacheFilePath, {}, names));
    }
}
exports.ProcHacker = ProcHacker;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2hhY2tlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInByb2NoYWNrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkNBQXlFO0FBQ3pFLGlDQUF3RTtBQUN4RSxpREFBd0M7QUFDeEMsK0JBQTRCO0FBQzVCLHlDQUFzQztBQUN0Qyx5Q0FBOEc7QUFDOUcseUNBQTRDO0FBQzVDLGlDQUF3RDtBQUN4RCxpQ0FBa0M7QUFFbEMsTUFBTSxTQUFTLEdBQWM7SUFDekIsb0JBQVEsQ0FBQyxHQUFHO0lBQ1osb0JBQVEsQ0FBQyxHQUFHO0lBQ1osb0JBQVEsQ0FBQyxHQUFHO0NBQ2YsQ0FBQztBQUVGLE1BQU0sUUFBUyxTQUFRLHdCQUFZO0lBRS9CLFlBQTRCLE1BQWtCLEVBQWtCLFFBQWU7UUFDM0UsS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBREwsV0FBTSxHQUFOLE1BQU0sQ0FBWTtRQUFrQixhQUFRLEdBQVIsUUFBUSxDQUFPO1FBSS9ELGFBQVEsR0FBRyxJQUFJLEdBQUcsQ0FBVyxTQUFTLENBQUMsQ0FBQztRQUNqRCxVQUFLLEdBQUcsQ0FBQyxDQUFDO0lBSGpCLENBQUM7SUFLRCxVQUFVO1FBQ04sS0FBSyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ3BDLE9BQU8sQ0FBQyxDQUFDO1NBQ1o7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsYUFBYSxDQUFDLElBQWtCO1FBQzVCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDM0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNCLElBQUksZ0JBQWdCLEdBQXFDLElBQUksQ0FBQztRQUM5RCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDakMsS0FBSyxNQUFNLElB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